// CryptoStart.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "AutoResult.h"
#include "AutoHandle.h"
using namespace std;

class CMsgData;

void printBlob( ostream& os, BYTE* buffer, DWORD length, int indent, bool lineb );
void printBuffer( ostream& os, CONST char* varname, BYTE* buffer, DWORD length );
void printSymKey( ostream& os, BYTE* symBuffer, DWORD symBufferLength );
void printMsgData( ostream& os, char* varname, CMsgData& symData );
void doAes( ostream& os, HCRYPTPROV hprov );
void doRsa( ostream& os, HCRYPTPROV hprov );
void printPublicKey( ostream& os, BYTE* buffer, DWORD length );
void printPrivateKey( ostream& os, BYTE* buffer, DWORD length );
void doHeader( ostream& os );


class CMsgData
{
public:
    const char* _msg;
    BYTE _cipher[400];
    DWORD _dataLength;

public:
    CMsgData( )       {

    }

    ~CMsgData( )      {
        _dataLength = 0;
    }

    void encrypt( HCRYPTKEY hkey, DWORD flags, const char* msg )
    {
        BoolResult br;
        _msg = msg;
        _dataLength = strlen( msg ) + 1;
        memset( _cipher, 0, sizeof(_cipher) );
        memcpy( _cipher, msg, _dataLength );
        br << CryptEncrypt( hkey, NULL, TRUE, flags, _cipher, &_dataLength, _countof(_cipher) );
    }
};



int wmain( int argc, wchar_t* argv[] )
{
    AutoCryptProv hprov;
    BoolResult br;
    
    //ofstream srcfile;
    //srcfile.open( "data.cpp" );
    ostream& srcfile = cout;


    // Delete previous key set
    br << CryptAcquireContext( &hprov, NULL, NULL, PROV_RSA_AES, CRYPT_DELETEKEYSET );

    // Get default provider for RSA/AES
    br << CryptAcquireContext( &hprov, NULL, NULL, PROV_RSA_AES, CRYPT_NEWKEYSET );

    doHeader( srcfile );

    doAes( srcfile, hprov );

    doRsa( srcfile, hprov );

    // srcfile.close();

    return 0;
}

void doHeader( ostream& os )
{
    os <<
        "// This file is generated by a tool - do not edit" << endl <<
        "// It is created by CryptoStart.exe utility. It contains the following" << endl <<
        "// data structures:" << endl <<
        "//     - Symmetric AES 128 Key blob" << endl <<
        "//     - RSA 1024 private key blob" << endl <<
        "//     - 3 messages data, encrypted by symmetric algorithm (clear and cipher)" << endl <<
        "//     - 1 message encrypted by rsa algorithm (clear and cipher)" << endl <<
        endl <<
        "#include \"CryptoData.h\"" << endl <<
        endl << endl;
}


void doAes( ostream& os, HCRYPTPROV hprov )
{
    AutoCryptKey hkeyAes;
    BoolResult br;

    br << CryptGenKey( hprov, CALG_AES_128, CRYPT_EXPORTABLE, &hkeyAes );

    // Encrypt 3 messages with symmetric key
    CMsgData msg1, msg2, msg3;
    msg1.encrypt( hkeyAes, CRYPT_OAEP, "short" );
    msg2.encrypt( hkeyAes, CRYPT_OAEP, "longer message" );
    msg3.encrypt( hkeyAes, CRYPT_OAEP, "The quick brown fox jumps over the lazy dog" );

    // export the symmetric key
    BYTE symBuffer[400];
    DWORD symBufferLength = _countof(symBuffer);
    br << CryptExportKey( hkeyAes, NULL, PLAINTEXTKEYBLOB, 0, symBuffer, &symBufferLength );

    // print the symmetric key
    printSymKey( os, symBuffer, symBufferLength );

    printMsgData( os, "symMsg1", msg1 );
    printMsgData( os, "symMsg2", msg2 );
    printMsgData( os, "symMsg3", msg3 );
}


void doRsa( ostream& os, HCRYPTPROV hprov )
{
    AutoCryptKey hkey;
    BoolResult br;
    CMsgData msg;

    br << CryptGenKey( hprov, CALG_RSA_KEYX, (1024 << 16) | CRYPT_EXPORTABLE, &hkey );


     // Crypt a message asymmetrically. Make sure clear text is less than 128 bytes
    msg.encrypt( hkey, CRYPT_OAEP, "Where do you want to go today?" );

    // Just for fun, decrypt the key
    BYTE back[400];
    DWORD blen = msg._dataLength;
    memset( back, 0, sizeof(back) );
    memcpy( back, msg._cipher, msg._dataLength );
    br << CryptDecrypt( hkey, NULL, TRUE, CRYPT_OAEP, back, &blen );

    // export both private and public key
    BYTE publicBuffer[400], privateBuffer[800];
    DWORD publicBufferLength = _countof(publicBuffer);
    DWORD privateBufferLength = _countof(privateBuffer);
    br << CryptExportKey( hkey, NULL, PUBLICKEYBLOB, 0, publicBuffer, &publicBufferLength );
    br << CryptExportKey( hkey, NULL, PRIVATEKEYBLOB, 0, privateBuffer, &privateBufferLength );

    // print the keys
    printPublicKey( os, publicBuffer, publicBufferLength );
    printPrivateKey( os, privateBuffer, privateBufferLength );

    printMsgData( os, "rsaMsg", msg );
 
};


void printBlob( ostream& os, BYTE* buffer, DWORD length, int indent, bool lineb )
{
    char* inds = 
        (indent==0) ? "" :
        (indent==1) ? "    " :
        (indent==2) ? "        " :
        (indent==3) ? "            " :
                      "                ";

    for( DWORD i=0; i<length; ++i ) {
        if( lineb ) {
            if( i!=0 && i%8 == 0 ) {
                os << endl << inds;
            }
        }
        int b = buffer[i];
        char* com = (i+1==length) ? "" : ", ";
        os << "0x" << hex << setw(2) << setfill('0') << b << com;
        os << dec << setw(0) << setfill(' ');
    }
}

void printBuffer( ostream& os, const char* varname, BYTE* buffer, DWORD length )
{
    os << "BYTE " << varname << "[" << length << "] = {" << endl << "    ";
    printBlob( os, buffer, length, 1, true );
    os << endl << "};" << endl;
}

void printFieldBuffer( ostream& os, const char* varname, BYTE* buffer, DWORD length, bool comma )
{
    char* commas = comma ? "," : "";
    os << "    {" << endl << "        ";
    printBlob( os, buffer, length, 2, true );
    os << endl << "    }" << commas << " // " << varname << endl;;
};

void printMsgData( ostream& os, char* varname, CMsgData& symData )
{
    os << "struct CMsgData " << varname << " = {" << endl;;
    os << "    \"" << symData._msg << "\"," << endl;
    printFieldBuffer( os, "cipher", symData._cipher, symData._dataLength, true );
    os << "    " << symData._dataLength << endl << "};" << endl << endl;
}

void printBlobHeader( ostream& os, BLOBHEADER* header )
{
    os << "    " << 0 + header->bType << ",\t\t// bType" << endl;
    os << "    " << 0 + header->bVersion << ",\t\t// bVersion" << endl;
    os << "    " << 0 + header->reserved << ",\t\t// reserved" << endl;
    os << "    0x" << hex << header->aiKeyAlg << dec << ",\t// aiKeyAlg" << endl;
}

void printSymKey( ostream& os, BYTE* symBuffer, DWORD symBufferLength )
{
    printBuffer( os, "symmetricKeyBlob", symBuffer, symBufferLength );
    os << endl;

    BLOBHEADER* blobHeader = (BLOBHEADER*)symBuffer;

    os << "struct CSymmetricKeyExtract symKeyExtract = {" << endl;
    printBlobHeader( os, blobHeader );
    DWORD s = *(DWORD*)(blobHeader+1);
    os << "    " << s << ",\t\t// size" << endl;
    printFieldBuffer( os, "blob", (BYTE*)((DWORD*)(blobHeader+1)+1), s, false );
    os << "};" << endl << endl << endl;
}


void printPublicKey( ostream& os, BYTE* buffer, DWORD length )
{
    printBuffer( os, "publicKeyBlob", buffer, length );
    os << endl;

    BLOBHEADER* header = (BLOBHEADER*)buffer;
    RSAPUBKEY* rsapub = (RSAPUBKEY*)(header+1);
    BYTE* modulus = (BYTE*)(rsapub + 1);
    DWORD modulusLength = length - (modulus-buffer);

    os << "struct CPublicKeyExtract pubKeyExtract = {" << endl;
    printBlobHeader( os, header );
    os << "    " << rsapub->magic << ",\t\t// magic=";
    char* p = (char*)&rsapub->magic;
    for( int i=0; i<4; ++i ) {
        os << *p++;
    }
    os << endl;
    os << "    " << rsapub->bitlen << ",\t// bitlen" << endl;
    os << "    " << rsapub->pubexp << ",\t\t// public exponent" << endl;
    printFieldBuffer( os, "modulus", modulus, modulusLength, false );
    os << "};" << endl << endl;
}



void printPrivateKey( ostream& os, BYTE* buffer, DWORD length )
{
    printBuffer( os, "privateKeyBlob", buffer, length );
    os << endl;

    BLOBHEADER* header = (BLOBHEADER*)buffer;
    RSAPUBKEY* rsapub = (RSAPUBKEY*)(header+1);

    DWORD modulusLength = rsapub->bitlen / 8;
    DWORD prime1Length = rsapub->bitlen / 16;
    DWORD prime2Length = rsapub->bitlen / 16;
    DWORD exp1Length = rsapub->bitlen / 16;
    DWORD exp2Length = rsapub->bitlen / 16;
    DWORD coefficientLength = rsapub->bitlen / 16;
    DWORD privExpLength = rsapub->bitlen / 8;
    
    DWORD total = sizeof(*header) + sizeof(*rsapub) + modulusLength + 
        prime1Length + prime2Length + exp1Length + exp2Length + coefficientLength + privExpLength;
    _ASSERTE( total == length );

    BYTE* modulus = (BYTE*)(rsapub + 1);
    BYTE* prime1 = modulus + modulusLength;
    BYTE* prime2 = prime1 + prime1Length;
    BYTE* exp1 = prime2 + prime2Length;
    BYTE* exp2 = exp1 + exp1Length;
    BYTE* coefficient = exp2 + exp2Length;
    BYTE* privExp = coefficient + coefficientLength;

    os << "struct CPrivateKeyExtract prvKeyExtract = {" << endl;
    printBlobHeader( os, header );
    os << "    " << rsapub->magic << ",\t\t// magic=";
    char* p = (char*)&rsapub->magic;
    for( int i=0; i<4; ++i ) {
        os << *p++;
    }
    os << endl;
    os << "    " << rsapub->bitlen << ",\t// bitlen" << endl;
    os << "    " << rsapub->pubexp << ",\t// public exponent" << endl;
    printFieldBuffer(os, "modulus", modulus, modulusLength, true );
    printFieldBuffer(os, "prime1", prime1, prime1Length, true );
    printFieldBuffer(os, "prime2", prime2, prime2Length, true );
    printFieldBuffer(os, "exp1", exp1, exp1Length, true );
    printFieldBuffer(os, "exp2", exp2, exp2Length, true );
    printFieldBuffer(os, "coefficient", coefficient, coefficientLength, true );
    printFieldBuffer(os, "privExp", privExp, privExpLength, false );
    os << "};" << endl << endl;
}
